using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System;

/**
 * 	Component for IndoorMapGeneratorScript.
 * 
 * 	Summary:
 * 		Takes in a 2d array of MarchingSquares (determined and generated by MarchingSquaresComponent)
 * 		and generates a 2d mesh base ("floor") from it.
 * 
 * 
 * 	Usage:
 * 		Call SetTarget() method and pass in an object, which should become 2d mesh base for further map generation
 * 		(GameObject with MeshFilter and MeshRenderer components attached).
 * 		If target is set, GenerateMesh() method can be called, which takes 2d array of Marching Squares, creates mesh 
 * 		and assigns it to target object.
 * 
 * 		In order to optimise mesh (reduce number of vertices and triangles in a mesh), call OptimiseMesh() (not mandatory).
 *		
 */ 
public class MeshGenerator2DComponent : MeshGeneratorAbstractComponent {

	public 	Material 			debugMaterial;
	private MarchingSquare[,] 	marchingSquaresMap;

	//refactor lists to arrays of fixed size
	//(because it's possible (?) to know vertex count beforehand)?.
//	private List<Vector3> 	vertices;
//	private List<int> 		triangles;

	public void SatistfyDependencies(MarchingSquare[,] marchingSquaresMap) {
		if (marchingSquaresMap == null) {
			throw new NullReferenceException ("Invalid parameter passed as dependency");
		}
		this.marchingSquaresMap = marchingSquaresMap;
	}

	public override void GenerateMesh() {
		
		if (marchingSquaresMap == null) {
			throw new NullReferenceException ("Dependencies (map of Marching Squares) not satisfied or variable data was deleted");
		}

		vertices = new List<Vector3> ();
		triangles = new List<int> ();
		for (int x = 0; x < marchingSquaresMap.GetLength (0); ++x) {
			for (int z = 0; z < marchingSquaresMap.GetLength (1); ++z) {
				CreateTrianglesForSquare (marchingSquaresMap [x, z]);
			}
		}

		AssignMeshToTarget ();
		marchingSquaresMap = null;
	}


	public void GenerateMesh(MarchingSquare[,] marchingSquaresMap) {
		SatistfyDependencies (marchingSquaresMap);
		GenerateMesh ();
	}

	protected override void AssignMeshToTarget() {
		Mesh mapMesh = new Mesh ();

		try {
			targetObject.GetComponent<MeshFilter> ().mesh = mapMesh;
			mapMesh.vertices = vertices.ToArray ();
			mapMesh.triangles = triangles.ToArray ();
		} catch (NullReferenceException nullRefExc) {
			Debug.LogError ("Null pointer in assigning mesh to target object - target doesn't have MeshFilter / MeshRenderer attached? " +
				"GenerateMesh() was not performed correctly?");
		}
			
		mapMesh.RecalculateNormals ();
		mapMesh.RecalculateBounds ();
		mapMesh.Optimize ();
	}
		
	public override void OptimiseMesh() {
		
	}

	private void CreateTrianglesForSquare(MarchingSquare square) {
		switch(square.GetSquareConfig()) {
			case 0:
				break;

			case 1: 
				MeshifySquare (square.midPointLeft, square.midPointBottom, square.cornerBottomLeft);
				break;
			case 2: 
				MeshifySquare (square.cornerBottomRight, square.midPointBottom, square.midPointRight);
				break;
			case 4: 
				MeshifySquare (square.cornerTopRight, square.midPointRight, square.midPointTop);
				break;
			case 8: 
				MeshifySquare (square.cornerTopLeft, square.midPointTop, square.midPointLeft);
				break;

			case 3:
				MeshifySquare (square.midPointRight, square.cornerBottomRight, square.cornerBottomLeft, square.midPointLeft);
				break;
			case 6:
				MeshifySquare (square.midPointTop, square.cornerTopRight, square.cornerBottomRight, square.midPointBottom);
				break;
			case 9:
				MeshifySquare (square.cornerTopLeft, square.midPointTop, square.midPointBottom, square.cornerBottomLeft);
				break;
			case 12:
				MeshifySquare (square.cornerTopLeft, square.cornerTopRight, square.midPointRight, square.midPointLeft);
				break;
			case 5:
				MeshifySquare (square.midPointTop, square.cornerTopRight, square.midPointRight, square.midPointBottom, square.cornerBottomLeft, square.midPointLeft);
				break;
			case 10:
				MeshifySquare (square.cornerTopLeft, square.midPointTop, square.midPointRight, square.cornerBottomRight, square.midPointBottom, square.midPointLeft);
				break;

			case 7:
				MeshifySquare (square.midPointTop, square.cornerTopRight, square.cornerBottomRight, square.cornerBottomLeft, square.midPointLeft);
				break;
			case 11:
				MeshifySquare (square.cornerTopLeft, square.midPointTop, square.midPointRight, square.cornerBottomRight, square.cornerBottomLeft);
				break;
			case 13:
				MeshifySquare (square.cornerTopLeft, square.cornerTopRight, square.midPointRight, square.midPointBottom, square.cornerBottomLeft);
				break;
			case 14:
				MeshifySquare (square.cornerTopLeft, square.cornerTopRight, square.cornerBottomRight, square.midPointBottom, square.midPointLeft);
				break;

			case 15:
				MeshifySquare (square.cornerTopLeft, square.cornerTopRight, square.cornerBottomRight, square.cornerBottomLeft);
				break;
			
			default:
				break;
		}
	}

	private void MeshifySquare(params MidPoint[] points) {
		CreateVertices (points);

		if (points.Length >= 3) {
			CreateTriangleFromPoints (points [0], points [1], points [2]);
		}
		if (points.Length >= 4) {
			CreateTriangleFromPoints (points [0], points [2], points [3]);
		}
		if (points.Length >= 5) {
			CreateTriangleFromPoints (points [0], points [3], points [4]);
		}
		if (points.Length >= 6) {
			CreateTriangleFromPoints (points [0], points [4], points [5]);
		}
	}
		
	private void CreateVertices(MidPoint[] points) {
		for (int p = 0; p < points.GetLength(0); ++p) {
			if (points[p].GetVertexIndex() == Utils.INTEGER_INVALID_VALUE) {
				points [p].SetVertexIndex (vertices.Count);
				vertices.Add (points [p].GetUnitCoordinates ());
			}
		}
	}

	private void CreateTriangleFromPoints(MidPoint a, MidPoint b, MidPoint c) {
		triangles.Add (a.GetVertexIndex ());
		triangles.Add (b.GetVertexIndex ());
		triangles.Add (c.GetVertexIndex ());
	}
		
}
