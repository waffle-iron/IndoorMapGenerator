using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

/**
 * 	Component for IndoorMapGeneratorScript.
 * 
 * 	Summary:
 * 		Takes a mesh generated by MeshGenerator2DComponent and creates a separate 'wall mesh' for it.
 */ 
public class MeshGeneratorWallsComponent : MeshGeneratorAbstractComponent {

	// dependencies:
	private Mesh 			base2dMesh;
	public 	Material 		debugMaterial;
	private GameObject		floorObject;

	float 	wallHeight = 1.25f;

	// list of outline edges (where edge is a list of vertices belonging to given edge).
	private List<List<int>> outlineEdges = new List<List<int>> ();

	// keeping track of already checked vertices of a mesh (so checks are not performed multiple times).
	private HashSet<int> 	checkedVertices = new HashSet<int> ();

	// dictionary - KEYS: vertices, VALUES: (list of) triangles that given vertex is a part of.
	private Dictionary<int, List<Triangle>> triangleDictionary = new Dictionary<int, List<Triangle>>();


	public void SatisfyDependencies(Mesh base2dMesh) {
		if (base2dMesh == null) {
			throw new NullReferenceException ("Invalid parameter passed as dependency");
		}
		this.base2dMesh = base2dMesh;
	}
		
	public override void GenerateMesh() {
		
		triangleDictionary.Clear ();
		outlineEdges.Clear ();
		checkedVertices.Clear ();
		vertices = new List<Vector3> ();
		triangles = new List<int> ();

		AnalyzeBaseMesh ();
		GenerateOutlineEdges ();



		foreach(List<int> outline in outlineEdges) {
			for (int outlineVertex = 0; outlineVertex < outline.Count-1; ++outlineVertex) {

				//generating wall mesh - calculating starting point
				int startIndex = vertices.Count;

				//generating wall mesh - creating mesh vertices for single wall rectangle (made up from 2 triangles)
				vertices.Add (base2dMesh.vertices [outline [outlineVertex]]); 	//left
				vertices.Add (base2dMesh.vertices [outline [outlineVertex+1]]); //right
				vertices.Add (base2dMesh.vertices [outline [outlineVertex]] - Vector3.up * wallHeight); //bottom left
				vertices.Add (base2dMesh.vertices [outline [outlineVertex+1]] - Vector3.up * wallHeight); //bottom right

				//creating triangles for wall rectangle mesh: 1st triangle
				triangles.Add(startIndex + 0);
				triangles.Add(startIndex + 2);
				triangles.Add(startIndex + 3);

				//creating triangles for wall rectangle mesh: 2nd triangle
				triangles.Add(startIndex + 3);
				triangles.Add(startIndex + 1);
				triangles.Add(startIndex + 0);
			}
		}

		AssignMeshToTarget ();
		base2dMesh = null;
	}

	protected override void AssignMeshToTarget() {
		Mesh mesh = new Mesh();
		try {
			targetObject.GetComponent<MeshFilter> ().mesh = mesh;
			mesh.vertices = vertices.ToArray ();
			mesh.triangles = triangles.ToArray ();
		} catch (NullReferenceException nullRefExc) {
			Debug.LogError ("Null pointer in assigning mesh to target object - target doesn't have MeshFilter / MeshRenderer attached? " +
				"GenerateMesh() was not performed correctly?");
		}

		mesh.RecalculateNormals ();
		mesh.RecalculateBounds ();
		mesh.Optimize ();
	}

	public void GenerateFloorMesh() {
		Vector3 pos = base2dMesh.bounds.center;
		pos -= (Vector3.up * wallHeight)/2f;
		floorObject.transform.position = pos;
		floorObject.transform.localScale = base2dMesh.bounds.size;
	}

	public void SetFloorTarget(GameObject target) {
		floorObject = target;
	}
		
	/**
	 * 	Reads base mesh triangles, stores it as Triangle objects and adds them to dictionary accordingly.
	 */ 
	private void AnalyzeBaseMesh() {
		if (base2dMesh.triangles.Length % 3 == 0) {
			Debug.Log ("base2dMesh triangles are divideable by 3 (OK)");
		} else {
			Debug.LogError ("base2dMesh triangles are NOT divideable by 3, error in provided mesh.");
		}
			

		Triangle triangle = new Triangle ();
		for (int t = 0; t < base2dMesh.triangles.Length; t += 3) {
			triangle = new Triangle (
				base2dMesh.triangles[t],
				base2dMesh.triangles[t+1],
				base2dMesh.triangles[t+2]
			);

			AddTriangleToDictionary (triangle.triangleVertexA, triangle);
			AddTriangleToDictionary (triangle.triangleVertexB, triangle);
			AddTriangleToDictionary (triangle.triangleVertexC, triangle);
		}
	}
		
	/**
	 * 	Reads base mesh vertices, loops over each of them and gets outline edge vertices out of them.
	 */ 
	private void GenerateOutlineEdges() {
		// looping over each vertex in a base mesh
		for (int vertex = 0; vertex < base2dMesh.vertices.Length; ++vertex) {
			
			// if vertex was already checked, then we skip to the next loop.
			if (!checkedVertices.Contains(vertex)) {
				int nextOutlineVertex = NextOutlineVertex (vertex);

				// if nextOutlineVertex equals INTEGER_INVALID_VALUE, it means that next vertex in outline does not exist
				if (nextOutlineVertex != Utils.INTEGER_INVALID_VALUE) {
					checkedVertices.Add (vertex);

					List<int> newOutline = new List<int> ();
					newOutline.Add (vertex);
					outlineEdges.Add (newOutline);

					FollowOutline (nextOutlineVertex, outlineEdges.Count - 1);
					outlineEdges [outlineEdges.Count - 1].Add (vertex);
				}
			}
		}
	}

	/**
	 * 	Recursive method for following an outline edge (started with vertex) until every vertex in an given edge
	 * 	is checked and processed.
	 */ 
	private void FollowOutline(int vertex, int outlineVertexIndex) {
		outlineEdges [outlineVertexIndex].Add (vertex);
		checkedVertices.Add (vertex);
		int nextVertex = NextOutlineVertex (vertex);

		if (nextVertex != Utils.INTEGER_INVALID_VALUE) {
			FollowOutline (nextVertex, outlineVertexIndex);
		}
	}

	/**
	 * 	Takes a vertex which belongs to an outline edge of a mesh and returns next vertex in this outline.
	 */ 
	private int NextOutlineVertex(int vertex) {
		// storing all of the triangles which are adjacent to passed in vertex index.
		List<Triangle> vertexAdjacentTriangles = triangleDictionary [vertex];

		// looping over each triangle in adjacency list.
		for (int t = 0; t < vertexAdjacentTriangles.Count; ++t) {
			Triangle triangle = vertexAdjacentTriangles [t];

			// looping over all 3 vertices (called 'corners' here) in a given triangle.
			for (int corner = 0; corner < 3; ++corner) {
				int triangleCorner = triangle[corner];

				// passing two vertices (vertex and triangleCorner) for validation but only
				// if they are not the same or triangleCorner was not already checked.
				if (triangleCorner != vertex && !checkedVertices.Contains(triangleCorner)) {
					if (IsOutlineEdge(vertex, triangleCorner)) {
						return triangleCorner;
					}
				}
			}
		}

		return Utils.INTEGER_INVALID_VALUE;
	}

	/**
	 * 	Checks whether a pair of two vertices (vertexA, vertexB) is a part of outline edge of a mesh.
	 * 
	 * 	(Two randomly chosen vertices can form an outline edge only when they are a part of only one common triangle)
	 * 	(If [vertexA] is adjacent to triangles [t10], [t11] and [t12], then list of adjacent triangles of [vertexB] must contain
	 * 	 [t10] OR [t11] OR [t12] in order for them to form an outline edge. Eg: ([t10], [t9], [t8]) or ([t7], [t12], [t20]) or ([t11])). 
	 */ 
	private bool IsOutlineEdge(int vertexA, int vertexB) {
		List<Triangle> vertexAAdjacentTriangles = triangleDictionary [vertexA];
		int sharedTriangles = 0;

		for (int t = 0; t < vertexAAdjacentTriangles.Count; ++t) {
			if (TriangleContainsVertex(vertexAAdjacentTriangles[t], vertexB)) {
				++sharedTriangles;
				if (sharedTriangles > 1) {
					break;
					//return false;
				}
			}
		}
			
		return (sharedTriangles == 1)? true : false;
	}
		
	/**
	 * 	Checks if given vertex is a part of triangle. 
	 */ 
	private bool TriangleContainsVertex(Triangle triangle, int vertex) {
		if (triangle.triangleVertexA == vertex ||
			triangle.triangleVertexB == vertex ||
			triangle.triangleVertexC == vertex) {
			return true;
		}
		return false;
	}

	/**
	 * 	Adds triangle to triangles dictionary.
	 */ 
	private void AddTriangleToDictionary(int vertex, Triangle triangle) {
		// if given vertex is already in a dictionary, adds corresponding triangle as another value
		if (triangleDictionary.ContainsKey(vertex)) {
			triangleDictionary [vertex].Add (triangle);
		} 
		//if vertex does not exist in dictionary, creates new (key,value) pair (vertex,list with this triangle)
		else {
			List<Triangle> list = new List<Triangle>();
			list.Add(triangle);
			triangleDictionary.Add(vertex, list);
		}
	}

	public override void OptimiseMesh() {

	}

}
